#' trans_behav - thermoregulatory model using a transient heat budget
#'
#' This model uses the transient heat budget models (i.e. accounting for heat storage and
#' hence lag-effects of body size) to simulate thermoregulatory behaviour. .
#' @encoding UTF-8
#' @param t time intervals (s) at which output is required
#' @param Tc_init = Tairf(1), initial temperature (deg C) Organism shape, 0-5, Determines whether standard or custom shapes/surface area/volume relationships are used: 0=plate, 1=cyl, 2=ellips, 3=lizard (desert iguana), 4=frog (leopard frog), 5=custom (see details)
#' @param Ts_init = Tc_init + 0.1, initial shell temperature (deg C)
#' @param To_init = Tc_init + 0.2, initial surface temperature (deg C)
#' @param Ww_g = 500, weight (g)
#' @param T_F_min = 33, # user-specified fur thermal conductivity (W/mK), not used if 0
#' @param T_F_max = 38, # fur depth, dorsal (m)
#' @param T_B_min = 25, # fur depth, ventral (m)
#' @param CT_max = 43, # core temperature (Â°C)
#' @param rho_body animal density (kg/m3)
#' @param lump = 1, one lump (1) or two lump (2) model?
#' @param x_shell = 0.001, shell thickness, m
#' @param q  metabolic rate (W/m3)
#' @param c_body = 3073, specific heat of flesh (J/kg-C)
#' @param c_body_inner = c_body, Specific heat of flesh J/(kg-K)
#' @param c_body_outer = c_body, Specific heat of outer shell J/(kg-K)
#' @param k_flesh = 0.5, conductivity of flesh (W/mK)
#' @param k_inner = k_flesh, Thermal conductivity of inner shell (W/mK, range: 0.412-2.8)
#' @param k_outer = k_flesh, Thermal conductivity of outer shell (W/mK, range: 0.412-2.8)
#' @param emis = 0.95, emissivity of skin (-)
#' @param alpha = 0.85, animal solar absorptivity (-)
#' @param geom = 2, Organism shape, 0-5, Determines whether standard or custom shapes/surface area/volume relationships are used: 0=plate, 1=cyl, 2=ellips, 3=lizard (desert iguana), 4=frog (leopard frog), 5=custom (see parameter 'shape_coeffs')
#' @param shape_b = 1/5, Proportionality factor (-) for going from volume to area, represents ratio of width:height for a plate, length:diameter for cylinder, b axis:a axis for ellipsoid
#' @param shape_c = 1/5, Proportionality factor (-) for going from volume to area, represents ratio of length:height for a plate, c axis:a axis for ellipsoid
#' @param shape_coefs = c(10.4713,.688,0.425,0.85,3.798,.683,0.694,.743), Custom surface area coefficients. Operates if posture = 5, and consists of 4 pairs of values representing the parameters a and b of a relationship AREA=a*Ww_g^b, where AREA is in cm2 and Ww_g is in g. The first pair are a and b for total surface area, then a and b for ventral area, then for sillhouette area normal to the sun, then sillhouette area perpendicular to the sun
#' @param posture = 'n', pointing normal 'n' or parallel 'p' to the sun's rays, or average 'b'?
#' @param orient = 1, does the object orient toward the sun? (0,1)
#' @param fatosk = 0.4, solar configuration factor to sky (-)
#' @param fatosb = 0.4, solar configuration factor to substrate (-)
#' @param alpha_sub = 0.2, substrate solar reflectivity, decimal percent
#' @param pctdif = 0.1, proportion of solar energy that is diffuse (rather than direct beam)
#' @param Tairf_sun air temperature function with time in sun, generated by 'approxfun' (deg C)
#' @param Tairf_shade air temperature function with time in shade, generated by 'approxfun' (deg C)
#' @param Tradf_sun radiant temperature function with time in sun, generated by 'approxfun'(deg C), averaging ground and sky
#' @param Tradf_shd radiant temperature function with time in shade, generated by 'approxfun'(deg C), averaging ground and sky
#' @param velf_sun wind speed function with time in sun, generated by 'approxfun' (m/s)
#' @param velf_shd wind speed function with time in shade, generated by 'approxfun' (m/s)
#' @param Qsolf_sun solar radiation function with time in sun, generated by 'approxfun' (W/m2)
#' @param Qsolf_shd solar radiation function with time in shade, generated by 'approxfun' (W/m2)
#' @param Zenf zenith angle of sun function with time, generated by 'approxfun' (90 is below horizon), degrees
#' @param press air pressure (Pa)
#' @return Tc Core temperature (deg C)
#' @return Ts 'Skin' / shell temperature (deg C)
#' @return To Outer temperature (deg C)
#' @return Tcf Final (steady state) temperature (deg C), if conditions remained constant indefinately
#' @usage trans_behav(Ww_g = 500, NGEOM = 4, GMREF = 3, FURTHRMK = 0, ZFURD = 2E-03, ZFURV = 2E-03, TC = 37, TCMAX = 45, TA = 20, TGRD = TA, TSKY = TA, VEL = 0.1, RH = 5, QSOLR = 0, Z = 20, SHADE = 0, NITESHAD = 0,...)
#' @export
trans_behav <- function(t = seq(1, 60),
Tc_init = rep(20, 60),
Ts_init = Tc_init + 0.1,
To_init = Tc_init + 0.2,
Ww_g = 500,
T_F_min = 33,
T_F_max = 38,
T_B_min = 25,
CT_max = 43,
rho_body = 932,
x_shell = 0.001,
lump = 1,
q =0,
c_body = 3073,
c_body_inner = c_body,
c_body_outer = c_body,
k_flesh = 0.5,
k_inner = k_flesh,
k_outer = k_flesh,
emis = 0.95,
alpha = 0.85,
geom = 2,
shape_b = 1/5,
shape_c = 1/5,
shape_coefs = c(10.4713,.688,0.425,0.85,3.798,.683,0.694,.743),
posture = 'n',
orient = 1,
fatosk = 0.4,
fatosb = 0.4,
alpha_sub = 0.2,
pctdif = 0.1,
Tairf_sun = rep(20, 60),
Tairf_shd = rep(20, 60),
Tradf_sun = rep(20, 60),
Tradf_shd = rep(20, 60),
velf_sun = rep(1, 60),
velf_shd = rep(1, 60),
Qsolf_sun = rep(0, 60),
Qsolf_shd = rep(0, 60),
Zenf = rep(0, 60),
press = 101325) {

  # t = t
  # Tc_init = Tairf_shd(1)
  # Ts_init = Tc_init + 0.1
  # To_init = Tc_init + 0.2
  # Ww_g = 500
  # T_F_min = 33
  # T_F_max = 38
  # T_B_min = 25
  # CT_max = 43
  # rho_body = 932
  # x_shell = 0.001
  # lump = 1
  # q =0
  # c_body = 3073
  # c_body_inner = c_body
  # c_body_outer = c_body
  # k_flesh = 0.5
  # k_inner = k_flesh
  # k_outer = k_flesh
  # emis = 0.95
  # alpha = 0.85
  # geom = 2
  # shape_b = 1/5
  # shape_c = 1/5
  # shape_coefs = c(10.4713,.688,0.425,0.85,3.798,.683,0.694,.743)
  # posture = 'n'
  # orient = 1
  # fatosk = 0.4
  # fatosb = 0.4
  # alpha_sub = 0.2
  # pctdif = 0.1
  # Tairf_sun = Tairf_sun
  # Tairf_shd = Tairf_shd
  # Tradf_sun = Tradf_sun
  # Tradf_shd = Tradf_shd
  # velf_sun = velf_sun
  # velf_shd = velf_shd
  # Qsolf_sun = Qsolf_shd
  # Qsolf_shd = Qsolf_shd
  # Zenf = Zenf
  # press = press

  if (exists("day_results"))
  {
    rm(day_results)
  }  # clear the results, if any already in the memory

  # single site transient analysis using user-input microclimate

  require(deSolve)

  # get environmental data

  sumstats <- matrix(data = NA, nrow = 1, ncol = 12, byrow = FALSE, dimnames = NULL)
  act_window <- matrix(data = NA, nrow = 1 * 24, ncol = 5, byrow = FALSE, dimnames = NULL)
  colnames(sumstats) = c("doy", "maxrun", "sumact", "bouts", "mornbask", "mornfor", "mid1", "meanmid", "arvo",
                         "mrate.sum", "mrate.sum.inactive", "mrate.sum.active")

  times_sec <- seq(0, 3600 * 24, 3600)  # hours of day in seconds
  times <- seq(0, 3600 * 24, 10)  # sequence of seconds for a day
  times <- times[1:(length(times) - 1)]
  hours <- times/3600
  times_orig <- times

  # events

  emerge <- function(t, y, pars) {
    # if sun is up and body temperature greater than threshold for basking, then trigger 'emerge' event
    if (Zenf(t) != 90 & y[1] > T_B_min) {
      y[1] <- 0
    }
    return(y)
  }
  retreat <- function(t, y, pars) {
    # if sun is down or body temperature is lower than threshold for basking, then trigger 'retreat' event
    if (Zenf(t) == 90 | y[1] < T_B_min) {
      y[1] <- 0
    }
    return(y)
  }
  shuttle <- function(t, y, pars) {
    # if temperature exceeds voluntary max Tb or is lower than voluntary minimum, trigger 'shuttle' event
    if (y[1] >= T_F_max | y < T_F_min) {
      y[1] <- 0
    }
    return(y)
  }
  forage <- function(t, y, pars) {
    # if Tb exceeds voluntary min foraging temp, or reaches the shaded air temp (plus a bit, one degree, because
    # otherwise they chase a moving target in the afternoon and may never come out) in the case of an animal cooling
    # in the shade when the shaded air temp is higher than the T_F_min, trigger 'forage' event (have to also make sure
    # that shaded air temp isn't approaching the T_F_max)
    if (lump == 1) {
      return(y[1] - max(T_F_min, if (Tairf_shd(t) > T_F_max - 2) {
        0
      } else {
        Tairf_shd(t) + 1
      }))
    }
    if (lump == 2) {
      return(c(y[1] - max(T_F_min, if (Tairf_shd(t) > T_F_max - 2) {
        0
      } else {
        Tairf_shd(t) + 1
      }), y[2:3]))
    }
  }
  eventfun <- function(t, y, pars) {
    if (lump == 1) {
      return(y <- 1)
    }
    if (lump == 2) {
      return(y <- c(1, 1, 1))
    }
  }

  # behaviours

  morning <- function() {
    if (lump == 1) {
      Tbs_ode <- as.data.frame(ode(y = Tc_init, times = subtime, func = onelump_var, parms = indata, events = list(func = eventfun,
                                                                                                                   root = TRUE, terminalroot = 1), rootfun = emerge, method = "lsoda"))
      colnames(Tbs_ode) <- c("time", "Tb", "Tcfinal", "tau", "dTc")
    }
    if (lump == 2) {
      Tbs_ode <- as.data.frame(ode(y = c(Tc_init, Ts_init, To_init), times = subtime, func = twolump, parms = indata,
                                   events = list(func = eventfun, root = TRUE, terminalroot = 1), rootfun = emerge, method = "lsoda"))
      colnames(Tbs_ode) <- c("time", "Tb", "Ts", "To", "Tcf")
    }
    return(Tbs_ode)
  }

  afternoon <- function() {
    if (lump == 1) {
      Tbs_ode <- as.data.frame(ode(y = Tc_init, times = subtime, func = onelump_var, parms = indata, events = list(func = eventfun,
                                                                                                                   root = TRUE, terminalroot = 1), rootfun = retreat, method = "lsoda"))
      colnames(Tbs_ode) <- c("time", "Tb", "Tcfinal", "tau", "dTc")
    }
    if (lump == 2) {
      Tbs_ode <- as.data.frame(ode(y = c(Tc_init, Ts_init, To_init), times = subtime, func = twolump, parms = indata,
                                   events = list(func = eventfun, root = TRUE, terminalroot = 1), rootfun = retreat, method = "lsoda"))
      colnames(Tbs_ode) <- c("time", "Tb", "Ts", "To", "Tcf")
    }
    return(Tbs_ode)
  }

  warming <- function() {
    if (lump == 1) {
      Tbs_ode <- as.data.frame(ode(y = Tc_init, times = subtime, func = onelump_var, parms = indata, events = list(func = eventfun,
                                                                                                                   root = TRUE, terminalroot = 1), rootfun = shuttle, method = "lsoda"))
      colnames(Tbs_ode) <- c("time", "Tb", "Tcfinal", "tau", "dTc")
    }
    if (lump == 2) {
      Tbs_ode <- as.data.frame(ode(y = c(Tc_init, Ts_init, To_init), times = subtime, func = twolump, parms = indata,
                                   events = list(func = eventfun, root = TRUE, terminalroot = 1), rootfun = shuttle, method = "lsoda"))
      colnames(Tbs_ode) <- c("time", "Tb", "Ts", "To", "Tcf")
    }
    return(Tbs_ode)
  }

  cooling <- function() {
    if (lump == 1) {
      Tbs_ode <- as.data.frame(ode(y = Tc_init, times = subtime, func = onelump_var, parms = indata, events = list(func = eventfun,
                                                                                                                   root = TRUE, terminalroot = 1), rootfun = forage, method = "lsoda"))
      colnames(Tbs_ode) <- c("time", "Tb", "Tcfinal", "tau", "dTc")
    }
    if (lump == 2) {
      Tbs_ode <- as.data.frame(ode(y = c(Tc_init, Ts_init, To_init), times = subtime, func = twolump, parms = indata,
                                   events = list(func = eventfun, root = TRUE, terminalroot = 1), rootfun = forage, method = "lsoda"))
      colnames(Tbs_ode) <- c("time", "Tb", "Ts", "To", "Tcf")
    }
    return(Tbs_ode)
  }
  cat("computing transient heat budget \n")

  posture <- "n"  # pointing normal 'n' or parallel 'p' to the sun's rays, or average 'b'?
  Tc_init <- Tairf_shd(0)  # start with Tb at shaded air temp
  Ts_init <- Tc_init
  To_init <- Tc_init
  Tairf <- Tairf_sun
  Qsolf <- Qsolf_sun
  Tradf <- Tradf_sun
  velf <- velf_sun

  # first get Te and Tb in open
  if (lump == 1) {
    indata <- list(alpha = alpha, emis = emis, alpha_sub = alpha_sub, press = press, Ww_g = Ww_g, c_body = c_body, rho_body = rho_body,
                   q = q, k_flesh = k_flesh, geom = geom, posture = posture, orient = orient, shape_b = shape_b, shape_c = shape_c,
                   shape_coefs = shape_coefs, pctdif = pctdif, fatosk = fatosk, fatosb = fatosb, Tairf = Tairf, velf = velf,
                   Qsolf = Qsolf, Tradf = Tradf, Zenf = Zenf)
    indata$c_body = 0.1  #specific heat of flesh, J/(kg.C)
  }
  if (lump == 2) {
    indata <- list(Ww_g = Ww_g, x_shell = x_shell, geom = geom, k_inner = k_inner, k_outer = k_outer, q = q,
                   c_body_inner = c_body_inner, c_body_outer = c_body_outer, emis = emis, rho_body_body = rho_body_body, alpha = alpha, shape_coefs = shape_coefs,
                   shape_b = shape_b, shape_c = shape_c, posture = posture, orient = orient, fatosk = fatosk, fatosb = fatosb,
                   alpha_sub = alpha_sub, pctdif = pctdif, press = press)
    indata$c_body_inner = 0.1  #specific heat of flesh, J/(kg.C)
    indata$c_body_outer = 0.1  #specific heat of flesh, J/(kg.C)
  }
  if (lump == 1) {
    Te <- try(ode(y = Tc_init, times = times, func = onelump_var, parms = indata)[, 2])
  }
  if (lump == 2) {
    Te <- try(ode(y = c(Tc_init, Ts_init, To_init), times = times, func = twolump, parms = indata)[, 2])
  }
  if (class(Te) == "try-error") {
    Te <- rep(NA, length(times))
  }
  if (lump == 1) {
    indata$c_body <- 3073  #specific heat of flesh, J/(kg.C)
  }
  if (lump == 2) {
    indata$c_body_inner <- 3073  #specific heat of flesh, J/(kg.C)
    indata$c_body_outer <- 3073  #specific heat of flesh, J/(kg.C)
  }
  if (lump == 1) {
    Tb_open <- ode(y = Tc_init, times = times, func = onelump_var, parms = indata)[, 2]
  }
  if (lump == 2) {
    Tb_open <- ode(y = c(Tc_init, Ts_init, To_init), times = times, func = twolump, parms = indata)[, 2]
  }
  out <- 0  # initial foraging state
  bask <- 1  # initial basking state
  daybreak <- 0  # initialise daybreak flag
  posture <- "n"  # initial postural state
  arvo <- times[(length(times)/2):length(times)]  # second half of day
  zeniths <- as.data.frame(cbind(arvo, Zenf(arvo)))  # afternoon zenith angles
  colnames(zeniths) <- c("time", "zen")
  evening <- subset(zeniths, zen == 90)  # evening times
  if (nrow(evening) == 0) {
    subtime <- times
  } else {
    sunset <- evening[1, 1]  # time of sunset
    times <- times[times < sunset]  # non-sunset times
    subtime <- times  # starting times to work with
  }
  while (length(subtime) > 0) {
    # now go through the non-evening times and check for daybreak start of the simulation, sun is not up yet, keep
    # it in the shade and inactive until sun comes up
    if (daybreak == 0) {
      indata$posture <- "b"
      indata$Tairf <- Tairf_shd  # choose shaded environment
      indata$Tradf <- Tradf_shd
      indata$Qsolf <- Qsolf_shd
      indata$velf <- velf_shd
      Tbs <- morning()  # get Tbs until sun rises and basking threshold is reached
      Tc_last <- Tbs[nrow(Tbs), 2]  # get initial temp for next behavioural phase
      Tc_prev <- Tbs[nrow(Tbs) - 1, 2]
      while (sign(Tc_last) != sign(Tc_prev)) {
        # get past real zeros!
        Tc_init <- 0
        subtime <- subset(times, times > Tbs[nrow(Tbs), 1])  # get times post basking event, for the next behavioural phase
        Tbs2 <- morning()  # get Tbs until sun rises and basking threshold is reached
        Tc_last <- Tbs2[nrow(Tbs2), 2]  # get initial temp for next behavioural phase
        Tc_prev <- Tbs2[nrow(Tbs2) - 1, 2]
        Tbs <- rbind(Tbs, Tbs2)
      }
      Tbs$posture <- 0
      Tbs$active <- 0
      Tbs$state <- 0
      if (exists("day_results")) {
        day_results <- rbind(day_results, Tbs)
      } else {
        day_results <- Tbs
      }
      Tc_init <- Tbs[nrow(Tbs), 2]  # get initial temp for next behavioural phase
      if (lump == 2) {
        Ts_init <- Tbs[nrow(Tbs), 3]
        To_init <- Tbs[nrow(Tbs), 4]
      }
      subtime <- subset(times, times > Tbs[nrow(Tbs), 1])  # get times post basking event, for the next behavioural phase
      daybreak <- 1  # sun has now risen
    }
    while (bask == 1 & length(subtime) > 0) {
      # now in the basking period
      indata$Tairf <- Tairf_sun  # choose full sun environment
      indata$Tradf <- Tradf_sun
      indata$Qsolf <- Qsolf_sun
      indata$velf <- velf_sun
      if (Tc_init < T_F_min) {
        indata$posture <- "n"  # change posture to be normal to the sun - basking
        Tbs <- cooling()  # simulate Tb until it reaches T_F_min - i.e. until it can forage
        Tbs$posture <- 1
        Tbs$active <- 0
        Tbs$state <- 1
        if (exists("day_results")) {
          day_results <- rbind(day_results, Tbs)
        } else {
          day_results <- Tbs
        }
        Tc_init <- Tbs[nrow(Tbs), 2]
        if (lump == 2) {
          Ts_init <- Tbs[nrow(Tbs), 3]
          To_init <- Tbs[nrow(Tbs), 4]
        }
        subtime <- subset(times, times > Tbs[nrow(Tbs), 1])  # exclude basking time from next simulation
        if (length(subtime) == 0)
        {
          break
        }  # stop if got through the rest of the day simply basking
      }
      indata$posture <- "b"  # has now got to foraging temp, change to foraging posture
      if (length(subtime) == 0) {
        break
      }
      Tbs <- warming()
      Tbs$posture <- 0
      Tbs$active <- 1
      Tbs$state <- 2
      if (exists("day_results")) {
        day_results <- rbind(day_results, Tbs)
      } else {
        day_results <- Tbs
      }
      Tc_init <- Tbs[nrow(Tbs), 2]
      if (lump == 2) {
        Ts_init <- Tbs[nrow(Tbs), 3]
        To_init <- Tbs[nrow(Tbs), 4]
      }
      subtime <- subset(times, times > Tbs[nrow(Tbs), 1])
      if (length(subtime) == 0) {
        break
      }
      if (Tc_init > T_F_min) {
        bask <- 0
      }
    }
    if (length(subtime) == 0) {
      break
    }
    # if we got to here, the animal has been out foraging in the sun and has reached the maximum voluntary foraging
    # temp, so needs to go into shade
    indata$Tairf <- Tairf_shd
    indata$Tradf <- Tradf_shd
    indata$Qsolf <- Qsolf_shd
    indata$velf <- velf_shd
    Tbs <- cooling()  # simulate cooling in shade
    Tbs$posture <- 0
    Tbs$active <- 0
    Tbs$state <- 3
    if (exists("day_results")) {
      day_results <- rbind(day_results, Tbs)
    } else {
      day_results <- Tbs
    }
    Tc_init <- Tbs[nrow(Tbs), 2]
    if (lump == 2) {
      Ts_init <- Tbs[nrow(Tbs), 3]
      To_init <- Tbs[nrow(Tbs), 4]
    }
    subtime <- subset(times, times > Tbs[nrow(Tbs), 1])
    indata$Tairf <- Tairf_sun
    indata$Tradf <- Tradf_sun
    indata$Qsolf <- Qsolf_sun
    indata$velf <- velf_sun
    if (length(subtime) == 0) {
      break
    }
    Tbs <- warming()  # now go foraging again in the sun
    Tbs$posture <- 0
    Tbs$active <- 1
    Tbs$state <- 2
    if (exists("day_results")) {
      day_results <- rbind(day_results, Tbs)
    } else {
      day_results <- Tbs
    }
    Tc_init <- Tbs[nrow(Tbs), 2]
    if (lump == 2) {
      Ts_init <- Tbs[nrow(Tbs), 3]
      To_init <- Tbs[nrow(Tbs), 4]
    }
    subtime <- subset(times, times > Tbs[nrow(Tbs), 1])
    if (Tc_init < T_F_min) {
      indata$posture <- "n"
      indata$Tairf <- Tairf_sun
      indata$Tradf <- Tradf_sun
      indata$Qsolf <- Qsolf_sun
      indata$velf <- velf_sun
      Tbs <- afternoon()
      Tc_last <- Tbs[nrow(Tbs), 2]  # get initial temp for next behavioural phase
      Tc_prev <- Tbs[nrow(Tbs) - 1, 2]
      while (sign(Tc_last) != sign(Tc_prev)) {
        # get past real zeros!
        Tc_init <- 0
        if (lump == 2) {
          Ts_init <- 0
          To_init <- 0
        }
        subtime <- subset(times, times > Tbs[nrow(Tbs), 1])  # get times post basking event, for the next behavioural phase
        Tbs2 <- afternoon()
        Tc_last <- Tbs2[nrow(Tbs2), 2]  # get initial temp for next behavioural phase
        Tc_prev <- Tbs2[nrow(Tbs2) - 1, 2]
        Tbs <- rbind(Tbs, Tbs2)
      }
      Tbs$posture <- 1
      Tbs$active <- 0
      Tbs$state <- 1
      if (exists("day_results")) {
        day_results <- rbind(day_results, Tbs)
      } else {
        day_results <- Tbs
      }
      Tc_init <- Tbs[nrow(Tbs), 2]
      if (lump == 2) {
        Ts_init <- Tbs[nrow(Tbs), 3]
        To_init <- Tbs[nrow(Tbs), 4]
      }
      subtime <- subset(times, times > Tbs[nrow(Tbs), 1])
      if (length(subtime) == 0) {
        break
      }
      indata$posture <- "b"  # if got this far, time to retreat to the shade in prep for the evening
      indata$Tairf <- Tairf_shd
      indata$Tradf <- Tradf_shd
      indata$Qsolf <- Qsolf_shd
      indata$velf <- velf_shd
      Tbs <- morning()
      Tc_last <- Tbs[nrow(Tbs), 2]  # get initial temp for next behavioural phase
      Tc_prev <- Tbs[nrow(Tbs) - 1, 2]
      while (sign(Tc_last) != sign(Tc_prev)) {
        # get past real zeros!
        Tc_init <- 0
        if (lump == 2) {
          Ts_init <- 0
          To_init <- 0
        }
        subtime <- subset(times, times > Tbs[nrow(Tbs), 1])  # get times post basking event, for the next behavioural phase
        Tbs2 <- morning()
        Tc_last <- Tbs2[nrow(Tbs2), 2]  # get initial temp for next behavioural phase
        Tc_prev <- Tbs2[nrow(Tbs2) - 1, 2]
        Tbs <- rbind(Tbs, Tbs2)
      }
      Tbs$posture <- 0
      Tbs$active <- 0
      Tbs$state <- 0
      if (exists("day_results")) {
        day_results <- rbind(day_results, Tbs)
      } else {
        day_results <- Tbs
      }
      Tc_init <- Tbs[nrow(Tbs), 2]
      if (lump == 2) {
        Ts_init <- Tbs[nrow(Tbs), 3]
        To_init <- Tbs[nrow(Tbs), 4]
      }
      subtime <- subset(times, times > Tbs[nrow(Tbs), 1])
      if (length(subtime) == 0) {
        break
      }
    }
  }
  if (length(subtime) == 0 & nrow(evening) != 0) {
    # now simulate the evening
    subtime <- evening[, 1]
    indata$posture <- "b"
    indata$Tairf <- Tairf_shd
    indata$Tradf <- Tradf_shd
    indata$Qsolf <- Qsolf_shd
    indata$velf <- velf_shd
    if (lump == 1) {
      Tbs <- as.data.frame(ode(y = Tc_init, times = subtime, func = onelump_var, parms = indata, method = "lsoda"))
      colnames(Tbs) <- c("time", "Tb", "Tcfinal", "tau", "dTc")
    }
    if (lump == 2) {
      Tbs <- as.data.frame(ode(y = c(Tc_init, Ts_init, To_init), times = subtime, func = twolump, parms = indata,
                               method = "lsoda"))
      colnames(Tbs) <- c("time", "Tb", "Ts", "To", "Tcf")
    }
    Tbs$posture <- 0
    Tbs$active <- 0
    Tbs$state <- 0
    if (exists("day_results")) {
      day_results <- rbind(day_results, Tbs)
    } else {
      day_results <- Tbs
    }
  }

  day_results <- subset(day_results, day_results$time %in% times_orig)
  day_results$Te <- Te[1:nrow(day_results)]
  day_results$Tb_open <- Tb_open[1:nrow(day_results)]

  # prevent constant back-and-forth between sun and shade during transition points by imposing a limit on
  # detection of Tb change by the animal
  day_results$state[day_results$Tb < T_F_min + 0.15 & day_results$Tb > T_F_min - 0.15 & day_results$Tb_open > T_F_max] <- 3
  day_results$state[day_results$Tb < T_F_min + 0.15 & day_results$Tb > T_F_min - 0.15 & day_results$state == 2] <- 1
  day_results$active[day_results$Tb < T_F_min + 0.15 & day_results$Tb > T_F_min - 0.15] <- 0
  # day_results$state[day_results$Tb<T_F_min-0.1 & day_results$state!=1] <- 0
  # day_results$active[day_results$Tb<T_F_min-0.1] <- 0

  plottime <- day_results$time/3600
  interval <- length(times_orig)

  # now get metabolic rates MRT (ml O2 per h) <- 0.110 M 0.768 x 10(T Ã¢\200â 20) x log10(Q10)/10, from Craig White
  # emial 11/8/2014
  Q10 <- 2.44
  mrate.reptile <- (0.11 * Ww_g^0.768 * 10^((day_results$Tb - 20) * log10(Q10)/10)) * 0.0056 * (24/interval) *
    3600/1000  # 0.0056 converts to Watts, then convert to kJ
  day_results <- cbind(day_results, mrate.reptile)
  mrate.sum <- sum(day_results$mrate.reptile)
  inactive <- subset(day_results, active == 0)
  active <- subset(day_results, active == 1)
  mrate.sum.inactive <- sum(inactive$mrate.reptile)
  mrate.sum.active <- sum(active$mrate.reptile)
  T_F_maxtime_te <- length(Te[Te > T_F_max + 0.5])/(interval/24) * 60
  CT_maxtime_te <- length(Te[Te > CT_max])/(interval/24) * 60
  T_F_maxtime_tb_open <- length(Tb_open[Tb_open > T_F_max + 0.5])/(interval/24) * 60
  CT_maxtime_tb_open <- length(Tb_open[Tb_open > CT_max])/(interval/24) * 60
  T_F_maxtime <- length(day_results$Tb[day_results$Tb > T_F_max + 0.5])/(interval/24) * 60
  CT_maxtime <- length(day_results$Tb[day_results$Tb > CT_max + 0.5])/(interval/24) * 60
  maxTbopen <- max(Tb_open)
  minTbopen <- min(Tb_open)
  maxTe <- max(Te)
  minTe <- min(Te)
  maxTb <- max(day_results$Tb)
  minTb <- min(day_results$Tb)

  # now summarize to hourly activity times and max foraging bouts
  Hour <- trunc(day_results$time/3600)
  day_results <- cbind(Hour, day_results)
  active <- aggregate(day_results$active, by = list(day_results$Hour), sum)
  active <- active$x/(length(times_orig)/24) * 60
  y <- rle(day_results$active)
  maxrun <- max((y$lengths[y$values == 1]))/(interval/24) * 60
  z <- rle(day_results$state)
  morning.bask <- z$lengths[z$values == 1][1]/(interval/24) * 60
  active.bouts <- y$lengths[y$values == 1]
  total.bouts <- length(active.bouts)
  if (total.bouts > 1) {
    morning.bout <- y$lengths[2]/(interval/24) * 60
    arvo.bout <- y$lengths[length(y$lengths) - 1]/(interval/24) * 60
  } else {
    morning.bout <- maxrun
    arvo.bout <- maxrun
  }
  if (total.bouts > 2) {
    midday.bouts <- active.bouts[2:(length(active.bouts) - 1)]/(interval/24) * 60
    midday.bout1 <- midday.bouts[1]
    mean.midday.bout <- mean(midday.bouts)
  } else {
    midday.bout1 <- maxrun
    mean.midday.bout <- maxrun
  }

  if (maxrun == "-Inf") {
    maxrun <- 0
    morning.bout <- 0
    midday.bout1 <- 0
    mean.midday.bout <- 0
    arvo.bout <- 0
    morning.bask <- 0
  }
  sumact <- sum(active)

  sum_stats <- as.data.frame(t(c(Ww_g, T_F_min, T_F_max, maxrun, sumact, total.bouts, morning.bask, morning.bout,
                               midday.bout1, mean.midday.bout, arvo.bout, mrate.sum, mrate.sum.inactive, mrate.sum.active, T_F_maxtime_te,
                               CT_maxtime_te, T_F_maxtime_tb_open, CT_maxtime_tb_open, T_F_maxtime, CT_maxtime, maxTbopen, minTbopen, maxTe, minTe,
                               maxTb, minTb)), stringsAsFactors = FALSE)
  if (length(loc) == 2) {
    loc = paste(loc[1], loc[2])
  }
  sum_stats = cbind(loc, sum_stats)
  sum_stats[11:27] = round(sum_stats[11:27], 1)
  sum_stats[4:5] = round(sum_stats[4:5], 1)
  for (i in 0:23) {
    run <- subset(day_results, Hour == i)
    y <- rle(run$active)
    run <- max((y$lengths[y$values == 1]))/(interval/24) * 60
    if (run == "-Inf") {
      run <- 0
    }
    if (i == 0) {
      runs <- run
    } else {
      runs <- c(runs, run)
    }
  }
  act_window <- cbind(seq(0, 23, 1), active, runs)

  act_window <- as.data.frame(act_window)

  colnames(act_window) <- c("hour", "forage.time.minute", "forage.bout.minute")
  colnames(sum_stats) <- c("loc", "Ww_g", "T_F_min", "T_F_max", "maxrun", "sumact", "bouts", "mornbask", "mornfor",
                         "mid1", "meanmid", "arvo", "mrate.sum", "mrate.sum.inactive", "mrate.sum.active", "T_F_maxtime_te", "CT_maxtime_te",
                         "T_F_maxtime_tb_open", "CT_maxtime_tb_open", "T_F_maxtime", "CT_maxtime", "maxTbopen", "minTbopen", "maxTe", "minTe",
                         "maxTb", "minTb")

  Tair_shd <- Tairf_shd(day_results$time)
  day_results$Tair_shd <- Tair_shd

  return(list(day_results = day_results, sum_stats = sum_stats, act_window = act_window))
}
